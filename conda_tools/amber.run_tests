#!/usr/bin/env python
# Run most of AmberTools serial tests
''' Require: AMBERHOME

You need to call amber.setup_test_folders first (only do once)

     amber.setup_test_folders

Then run test (anywhere)

    amber.run_tests

Adjust the test by updating env TEST_TASK (please lookt at the code)
'''

from time import time
from contextlib import contextmanager
import os
import sys
import subprocess


@contextmanager
def change_folder(where):
    here = os.getcwd()
    os.chdir(where)
    yield
    os.chdir(here)


def gather_dif_files(amberhome):
    print("Writing diff files to test_dif.log")
    with open('test_dif.log', 'w') as fdif:
        with change_folder(amberhome):
            output = subprocess.check_output(
                'find . -iname "*.dif"', shell=True).decode()

            files = [fn for fn in output.split('\n') if fn]
            for fn in files:
                print(fn)
                with open(fn) as fh:
                    fdif.write('FILENAME: {}\n'.format(fn))
                    fdif.write(fh.read())


def get_tests_from_test_name(test_name, makefile_fn):
    # test.serial.sander.MM has a bunch of small tests.
    with open(makefile_fn) as fh:
        lines = fh.readlines()

    index_0 = 0
    index_next = -1
    for index, line in enumerate(lines):
        if line.startswith(test_name):
            break
    index_0 = index

    for index in range(index_0 + 1, 1000):
        if lines[index].startswith('test.'):
            break

    index_next = index
    my_lines = [
        word for word in ''.join(lines[index_0:index_next]).strip().split()
        if word != '\\'
    ]
    my_lines.pop(0)
    if my_lines[0].startswith('-cd'):
        return ' '.join(my_lines)
    return my_lines


def create_test_suite(excluded_tests):
    amberhome = os.getenv('AMBERHOME')
    if amberhome is None:
        raise EnvironmentError("Must set AMBERHOME")

    amber_test_dir = amberhome + '/test'
    ambertools_test_dir = amberhome + '/AmberTools/test'

    amber_test_suite_dict = {
        'serial.MM': [
            test
            for test in get_tests_from_test_name(
                'test.serial.sander.MM', amber_test_dir + '/Makefile') + [
                    'test.nmode',
                ] if test not in ['test.serial.sander.emap']
        ],
        'serial.QMMM':
        get_tests_from_test_name('test.serial.QMMM',
                                 amber_test_dir + '/Makefile'),
        'serial.sander.SEBOMD': ['test.serial.sander.SEBOMD'],
        'sanderapi': ['test.serial.sanderapi'],
    }

    ambertools_test_suite_dict = {
        'fast': [
            'test.cpptraj', 'test.pytraj', 'test.parmed', 'test.pdb4amber',
            'test.leap', 'test.antechamber', 'test.unitcell', 'test.reduce',
            'test.nab', 'test.mdgx', 'test.resp', 'test.sqm', 'test.gbnsr6',
            'test.elsize', 'test.paramfit', 'test.FEW', 'test.cphstats',
            'test.cpinutil'
        ],
        'mmpbsa': [
            'test.mmpbsa',
            'test.mm_pbsa',
        ],
        'rism': ['test.rism1d', 'test.rism3d.periodic'],
        'python': [
            'test.pytraj', 'test.parmed',
            'test.pdb4amber',
            'test.pymsmt'
        ],
    }

    for test_suite_dict in [amber_test_suite_dict, ambertools_test_suite_dict]:
        for k in test_suite_dict:
            for test in excluded_tests:
                try:
                    test_suite_dict[k].remove(test)
                except ValueError:
                    pass


    def gather(suite_dict, test_dir):
        for task, suite in suite_dict.items():
            suite_dict[task] = [(test_name, test_dir) for test_name in suite]

    gather(ambertools_test_suite_dict, ambertools_test_dir)
    gather(amber_test_suite_dict, amber_test_dir)

    all_suits = amber_test_suite_dict.copy()
    all_suits.update(ambertools_test_suite_dict)

    return all_suits


def execute(cmds):
    then = time()
    # adapted from StackOverflow
    # http://stackoverflow.com/a/4418193
    command = ' '.join(cmds)
    print(command)
    output_lines = []
    process = subprocess.Popen(
        command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
        shell=True)

    # Poll process for new output until finished
    while True:
        nextline = process.stdout.readline().decode('utf-8')
        if nextline == '' and process.poll() is not None:
            break
        sys.stdout.write('.')
        sys.stdout.flush()

        output_lines.append(nextline)
    output = ''.join(output_lines)
    now = time()
    time_diff = now - then
    if 'Program error' in output or 'possible FAILURE' in output or 'No rule to make target' in output:
        print('{0:.1f} (s), FAILURE'.format(time_diff))
    else:
        print('{0:.1f} (s), PASSED'.format(time_diff))
    return output, time_diff


def run_chunk(rank, test_suite_chunks):
    # type: (List[[str, str]]) -> None
    TIME_DICT = dict()
    ALL_OUTPUTS = []
    ERRORS = []
    test_suite = test_suite_chunks[rank]
    print('rank=', rank, 'test_suite', test_suite)
    for (test_name, test_dir) in test_suite:
        output, time_diff = execute(['cd', test_dir, '&&', 'make', test_name])
        TIME_DICT[test_name] = time_diff
        ALL_OUTPUTS.extend(output.split('\n'))
        if ('Program error' in output or
                'possible FAILURE' in output or
                'No rule to make target' in output):
            ERRORS.append(output)
    return TIME_DICT, ALL_OUTPUTS, ERRORS


def run_all(test_suite, num_cpus):
    import multiprocessing
    import functools
    import numpy as np
    import random

    if num_cpus == 1:
        print("Run test in serial")
        return run_chunk(0, [test_suite])
    else:
        print("Run test in parallel")
        if num_cpus < 1:
            num_cpus = multiprocessing.cpu_count()
        num_cpus = min(len(test_suite), num_cpus)
        print('num_cpus', num_cpus)
        random.shuffle(test_suite)
        test_suite_chunks = np.array_split(list(set(test_suite)), num_cpus)
        pool = multiprocessing.Pool(num_cpus)
        func =  functools.partial(run_chunk, test_suite_chunks=test_suite_chunks) 
        outputs = pool.map(func, range(num_cpus))

        TIME_DICT = outputs[0][0]
        for t in outputs[1:]:
            TIME_DICT.update(t[0])

        ALL_OUTPUTS = outputs[0][1]
        for a in outputs[1:]:
            ALL_OUTPUTS.extend(a[1])

        ERRORS = outputs[0][2]
        for e in outputs[1:]:
            ERRORS.extend(e[2])
        return TIME_DICT, ALL_OUTPUTS, ERRORS


def timer(msg=''):
    def wrap_0(func):
        def wrap(*args, **kwargs):
            t0 = time()
            out = func(*args, **kwargs)
            long_msg = "Finished {} in {:04.2f} (minutes)".format(msg,
                    (time() - t0) / 60.)
            print(long_msg)
            with open('test_summary.log', 'a') as fh:
                fh.write(long_msg + '\n')
            return out
        return wrap
    return wrap_0


@timer(msg='testing AmberTools')
def test_me(opt):
    sanderapi_tests = [
        'test.parm7', 'Fortran', 'Fortran2', 'C', 'CPP', 'Python', 'clean'
    ]
    amberhome = os.getenv('AMBERHOME')
    if not amberhome:
        raise EnvironmentError("Must set AMBERHOME")
    ambertools_test_dir = amberhome + '/AmberTools/test'
    amber_test_dir = amberhome + '/test'

    ERRORS = []
    ALL_OUTPUTS = []
    TIME_DICT = {}
    test_suite_dict = create_test_suite(opt.exclude)
    test_task = opt.task

    try:
        test_suite = test_suite_dict[
            test_task] if test_task != 'all' else sum(test_suite_dict.values(), [])
        if test_task == 'python':
            test_suite.extend(test_suite_dict['sanderapi'])
    except KeyError:
        test_suite = [
            (test_task, ambertools_test_dir),
        ]


    print('test_suite', sorted(test_suite))
    # amberXX/test/
    if test_task in ['serial.MM', 'serial.QMMM', 'serial.sander.SEBOMD']:
        print('serial MM and QMMM')
        test_folder = amber_test_dir
    # amberXX/AmberTools/test/
    else:
        print(amberhome + '/AmberTools/test/')
        test_folder = ambertools_test_dir

    TIME_DICT, ALL_OUTPUTS, ERRORS = run_all(test_suite, opt.num_cpus)

    if ERRORS:
        for out in ERRORS:
            print(out)

    n_passes = n_fails = n_program_errors = 0

    with open('test_out.log', 'w') as fh:
        for line in ALL_OUTPUTS:
            fh.write(line + '\n')
            if 'PASSED' in line:
                n_passes += 1
            if 'Program error' in line:
                n_program_errors += 1
            if 'possible FAILURE' in line:
                n_fails += 1

    gather_dif_files(amberhome)

    print(TIME_DICT)
    with open('test_timing.log', 'w') as fh:
        for k, v in TIME_DICT.items():
            fh.write("{}: {:06.2f} (s)\n".format(k, v))

    with open('test_summary.log', 'w') as fh:
        summary = """
{} file comparisons passed
{} file comparisons failed
{} tests experienced errors
""".format(n_passes, n_fails, n_program_errors)
        fh.write(summary)
        print(summary)

    return ERRORS


def main(args=None):
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--task',
            default='fast',
            help='test task')
    parser.add_argument('-x', '--exclude',
            default=[],
            help='Exlude tests')
    parser.add_argument('-n', '--num-cpus',
            default=-1,
            type=int,
            help='Run test in serial')
    opt = parser.parse_args(args)
    if opt.exclude:
        # "test.parmed, test.pytraj"
        if os.path.isfile(opt.exclude):
            with open(opt.exclude) as fh:
                opt.exclude = fh.read().replace('\n', '').split(',')
        else:
            opt.exclude = opt.exclude.split(',')
        print('TEST EXCLUDED', opt.exclude)
    errors = test_me(opt)
    assert len(errors) == 0


if __name__ == '__main__':
    main()
